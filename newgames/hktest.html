<!DOCTYPE html>
<html lang="en-us">

<head>
    <base href="https://cdn.jsdelivr.net/gh/web-ports/hollow-knight@main/">
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | Hollowa Knight</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            background: #231F20;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
        }

        #resolution-bar {
            margin: 10px 0;
            z-index: 1000;
        }

        #unity-container {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #unity-canvas {
            background: black;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #save-load-bar {
            margin: 5px 0;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <div id="loading-text" style="font-size: 32px; margin: 10px;">LOADING...</div>

    <!-- SAVE/LOAD BUTTONS -->
    <div id="save-load-bar">
        <button onclick="exportUnitySave()">ðŸ’¾ Save Game</button>
        <button onclick="document.getElementById('saveFileInput').click()">ðŸ“‚ Load Game</button>
        <input type="file" id="saveFileInput" style="display:none" accept=".json" onchange="importUnitySave(this.files[0])">
    </div>

    <!-- RESOLUTION SELECT -->
    <div id="resolution-bar">
        <label for="resolutionSelect">Resolution: </label>
        <select id="resolutionSelect">
            <option value="1280x720" selected>720p</option>
            <option value="960x540">540p</option>
            <option value="640x360">360p</option>
        </select>
    </div>

    <div hidden id="unity-container" class="unity-desktop">
        <canvas id="unity-canvas" width="1280" height="720" style="width:1280px;height:720px;"></canvas>
        <div id="unity-loading-bar">
            <div id="unity-logo"></div>
            <div id="unity-progress-bar-empty">
                <div id="unity-progress-bar-full"></div>
            </div>
        </div>
        <div id="unity-mobile-warning"> WebGL builds are not supported on mobile devices. </div>
    </div>

    <script>
        var loadingText = document.querySelector("#loading-text");
        let totalBytes = 0;
        let loadedBytes = 0;

        async function getSize(url) {
            try {
                const res = await fetch(url, { method: "HEAD" });
                return parseInt(res.headers.get("Content-Length") || "0", 10);
            } catch { return 0; }
        }

        async function fetchWithProgress(url) {
            const response = await fetch(url);
            const reader = response.body.getReader();
            let chunks = [];
            let received = 0;
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                received += value.length;
                loadedBytes += value.length;
                chunks.push(value);
                let mbDone = (loadedBytes / (1024 * 1024)).toFixed(2);
                let mbTotal = '909.17';
                loadingText.textContent = `LOADING... ${mbDone} MB / ${mbTotal} MB`;
            }
            let fullBuffer = new Uint8Array(received);
            let offset = 0;
            for (let chunk of chunks) {
                fullBuffer.set(chunk, offset);
                offset += chunk.length;
            }
            return fullBuffer.buffer;
        }

        async function mergeFiles(fileParts) {
            const buffers = await Promise.all(fileParts.map(part => fetchWithProgress(part)));
            const mergedBlob = new Blob(buffers);
            return URL.createObjectURL(mergedBlob);
        }

        function getParts(file, start, end) {
            let parts = [];
            for (let i = start; i <= end; i++) {
                parts.push(file + ".part" + i);
            }
            return parts;
        }

        (async () => {
            const allParts = [...getParts("Build/bog.data", 1, 44), ...getParts("Build/bog.wasm", 1, 2)];
            const sizes = await Promise.all(allParts.map(getSize));
            totalBytes = sizes.reduce((a, b) => a + b, 0);

            const [dataUrl, wasmurl] = await Promise.all([
                mergeFiles(getParts("Build/bog.data", 1, 44)),
                mergeFiles(getParts("Build/bog.wasm", 1, 2)),
            ]);

            var buildUrl = "Build";
            var loaderUrl = buildUrl + "/bog.loader.js";
            var config = {
                dataUrl: dataUrl,
                frameworkUrl: buildUrl + "/bog.framework.js",
                codeUrl: wasmurl,
                streamingAssetsUrl: "StreamingAssets",
                companyName: "Team Cherry & Truffled",
                productName: "Hollow Knight",
                productVersion: "1.0",
                devicePixelRatio: 1
            };

            var container = document.querySelector("#unity-container");
            container.hidden = false;
            var canvas = document.querySelector("#unity-canvas");
            var loadingBar = document.querySelector("#unity-loading-bar");
            var progressBarFull = document.querySelector("#unity-progress-bar-full");
            var mobileWarning = document.querySelector("#unity-mobile-warning");

            function setResolution(w, h) {
                canvas.width = w;
                canvas.height = h;
                canvas.style.width = w + "px";
                canvas.style.height = h + "px";
            }
            setResolution(1280, 720);

            document.getElementById('resolutionSelect').addEventListener('change', function () {
                const [w, h] = this.value.split('x').map(Number);
                setResolution(w, h);
            });

            if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                container.className = "unity-mobile";
                mobileWarning.style.display = "block";
                setTimeout(() => { mobileWarning.style.display = "none"; }, 5000);
            }

            loadingBar.style.display = "block";

            var script = document.createElement("script");
            script.src = loaderUrl;
            script.onload = () => {
                createUnityInstance(canvas, config, (progress) => {
                    progressBarFull.style.width = (100 * progress) + "%";
                }).then((unityInstance) => {
                    loadingText.remove();
                    loadingBar.style.display = "none";
                    canvas.style.display = "block";
                }).catch((message) => {
                    alert(message);
                });
            };
            document.body.appendChild(script);
        })();

        // ===== SAVE/LOAD SYSTEM =====

        // Find the IndexedDB that backs Unity's /idbfs (FILE_DATA)
        async function getFileDataDB() {
            const dbs = await indexedDB.databases();
            // Heuristic: look for an idbfs/FILE_DATA database. You can hard-code the name if you know it.
            const target = dbs.find(db => (db.name || '').toLowerCase().includes('idbfs') || (db.name || '').toLowerCase().includes('file_data'));
            if (!target) throw new Error('FILE_DATA DB not found');
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(target.name);
                req.onsuccess = e => resolve(e.target.result);
                req.onerror = e => reject(e);
            });
        }

        // Export full FILE_DATA as JSON (flush in-memory FS first)
       async function exportUnitySave() {
          try {
            if (typeof FS !== 'undefined' && FS.syncfs) {
              await new Promise(res => FS.syncfs(false, res)); // flush to IndexedDB
            }
        
            const db = await getFileDataDB();
            const tx = db.transaction(db.objectStoreNames, 'readonly');
            const allData = {};
            let pending = db.objectStoreNames.length;
        
            if (!pending) throw new Error('No object stores found in FILE_DATA DB');
        
            // Helper to encode binary to base64
            const toB64 = (buf) => {
              let bin = '';
              const bytes = new Uint8Array(buf);
              for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
              return btoa(bin);
            };
        
            for (const storeName of db.objectStoreNames) {
              const store = tx.objectStore(storeName);
        
              // We need both keys and values
              const valuesReq = store.getAll();
              const keysReq = store.getAllKeys();
        
              Promise.all([
                new Promise(res => valuesReq.onsuccess = () => res(valuesReq.result)),
                new Promise(res => keysReq.onsuccess = () => res(keysReq.result))
              ]).then(async ([values, keys]) => {
                const out = [];
                for (let i = 0; i < keys.length; i++) {
                  let val = values[i];
        
                  // Normalize to a serializable form
                  if (val instanceof Blob) {
                    const ab = await val.arrayBuffer();
                    out.push({ key: keys[i], kind: 'blob', mime: val.type || '', data: toB64(ab) });
                  } else if (val instanceof ArrayBuffer) {
                    out.push({ key: keys[i], kind: 'ab', data: toB64(val) });
                  } else if (ArrayBuffer.isView(val)) {
                    const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
                    out.push({ key: keys[i], kind: 'typed', dtype: val.constructor.name, data: toB64(ab) });
                  } else {
                    // Structured-cloneable JSON-like value
                    out.push({ key: keys[i], kind: 'json', value: val });
                  }
                }
                allData[storeName] = out;
        
                if (--pending === 0) {
                  const blob = new Blob([JSON.stringify(allData)], { type: 'application/json' });
                  const a = document.createElement('a');
                  a.href = URL.createObjectURL(blob);
                  a.download = 'unity_FILE_DATA_backup.json';
                  document.body.appendChild(a);
                  a.click();
                  a.remove();
                }
              }).catch(err => {
                console.error('Export read error for store', storeName, err);
              });
            }
          } catch (e) {
            console.error('Export failed:', e);
            alert('Failed to export save. See console for details.');
          }
        }

        
        async function importUnitySave(file) {
          try {
            const text = await file.text();
            const data = JSON.parse(text);
            const db = await getFileDataDB();
        
            // Helper to decode base64 to ArrayBuffer
            const fromB64 = (b64) => {
              const bin = atob(b64);
              const bytes = new Uint8Array(bin.length);
              for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
              return bytes.buffer;
            };
        
            const tx = db.transaction(db.objectStoreNames, 'readwrite');
        
            for (const storeName of db.objectStoreNames) {
              const store = tx.objectStore(storeName);
              await new Promise((resolve, reject) => {
                const req = store.clear();
                req.onsuccess = resolve;
                req.onerror = reject;
              });
        
              const entries = data[storeName] || [];
              for (const entry of entries) {
                let value;
        
                switch (entry.kind) {
                  case 'blob': {
                    const ab = fromB64(entry.data);
                    value = new Blob([ab], { type: entry.mime || '' });
                    break;
                  }
                  case 'ab': {
                    value = fromB64(entry.data);
                    break;
                  }
                  case 'typed': {
                    const ab = fromB64(entry.data);
                    const map = {
                      Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
                      Int32Array, Uint32Array, Float32Array, Float64Array, BigInt64Array, BigUint64Array
                    };
                    const Ctor = map[entry.dtype];
                    value = Ctor ? new Ctor(ab) : new Uint8Array(ab);
                    break;
                  }
                  case 'json':
                  default:
                    value = entry.value;
                    break;
                }
        
                // IMPORTANT: put(value, key) for out-of-line, no-generator stores
                await new Promise((resolve, reject) => {
                  const req = store.put(value, entry.key);
                  req.onsuccess = resolve;
                  req.onerror = reject;
                });
              }
            }
        
            tx.oncomplete = () => {
              if (typeof FS !== 'undefined' && FS.syncfs) {
                FS.syncfs(true, (err) => {
                  if (err) {
                    console.error('Error syncing FS:', err);
                    alert('Save imported, but memory sync failed. Try reloading the page.');
                  } else {
                    alert('Save loaded instantly! Open the in-game load menu if needed.');
                  }
                });
              } else {
                alert('Save imported. FS API not available to hot-load; reload the page to apply.');
              }
            };
        
            tx.onerror = (e) => {
              console.error('Import transaction error:', e);
              alert('Failed to import save. See console for details.');
            };
          } catch (e) {
            console.error('Import failed:', e);
            alert('Failed to import save. Is the file a valid backup?');
          }
        }


    </script>
</body>
</html>
